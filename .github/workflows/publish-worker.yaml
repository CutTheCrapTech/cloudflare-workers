# .github/workflows/publish-worker.yml
# This workflow handles the deployment of Cloudflare Workers.
# It is triggered by a workflow_call from the `publish.yaml` workflow upon a new release,
# or can be triggered manually via workflow_dispatch for a specific package.
name: Deploy Workers

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: "The scoped name of the worker package to deploy (e.g., '@cloudflare-workers/site')."
        required: true
        type: string
  workflow_call:
    inputs:
      published_packages:
        description: "JSON array of published packages from the changesets/action."
        required: true
        type: string
    secrets:
      INFISICAL_CLIENT_SECRET:
        required: true

jobs:
  prepare-deployment:
    name: Prepare Deployment Matrix
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.prepare_matrix.outputs.packages_json }}
    steps:
      - name: Prepare Deployment Matrix
        id: prepare_matrix
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PACKAGES_JSON="[]"
          # Manual workflow_dispatch run
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            PACKAGE_NAME="${{ inputs.package_name }}"
            echo "Manual run for package: $PACKAGE_NAME"
            LATEST_VERSION=$(gh release list --repo $GITHUB_REPOSITORY --limit 1 --json tagName --jq ".[] | select(.tagName | startswith(\"$PACKAGE_NAME@\")) | .tagName" | sed "s#$PACKAGE_NAME@##")
            if [ -z "$LATEST_VERSION" ]; then
              echo "::error::Could not find any releases for package $PACKAGE_NAME."
              exit 1
            fi
            echo "Found latest version: $LATEST_VERSION"
            PACKAGES_JSON=$(jq -n --arg name "$PACKAGE_NAME" --arg version "$LATEST_VERSION" '[{"name": $name, "version": $version}]')
          # Automated workflow_call run
          else
            echo "Automated run from published packages."
            PACKAGES_JSON='${{ inputs.published_packages }}'
          fi

          {
            echo "packages_json<<EOF"
            echo "$PACKAGES_JSON"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  deploy-workers:
    name: Deploy ${{ matrix.package.name }}
    needs: prepare-deployment
    if: ${{ needs.prepare-deployment.outputs.packages != '[]' && needs.prepare-deployment.outputs.packages != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read # To download release assets
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.prepare-deployment.outputs.packages) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0
        with:
          version: 10

      - name: Set up Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: "lts/*"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Set environment
        id: env
        run: |
          BRANCH_NAME=${{ github.ref_name }}
          if [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "prod" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [ "$BRANCH_NAME" = "staging" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
          echo "Using environment: $(cat $GITHUB_OUTPUT)"

      - name: Prepare for Deployment
        id: prepare-files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PACKAGE_NAME="${{ matrix.package.name }}"
          PACKAGE_VERSION="${{ matrix.package.version }}"
          TAG_NAME="${PACKAGE_NAME}@${PACKAGE_VERSION}"
          # Create a safe, unique temporary directory
          TEMP_DIR="deploy_${PACKAGE_NAME//\//-}_${{ github.run_id }}_${{ github.run_attempt }}"
          mkdir -p "$TEMP_DIR"
          echo "dist_dir=$TEMP_DIR/dist" >> $GITHUB_OUTPUT

          # Download and unzip the deployment artifact
          echo "Downloading and extracting dist.zip from ${TAG_NAME}"
          gh release download "$TAG_NAME" --pattern "dist.zip" --output "$TEMP_DIR/dist.zip"
          if [ $? -ne 0 ]; then
              echo "::error::Could not download dist.zip for ${TAG_NAME}."
              exit 1
          fi
          unzip "$TEMP_DIR/dist.zip" -d "$TEMP_DIR"

          # Prepare wrangler args from manifest
          MANIFEST_PATH="$TEMP_DIR/dist/worker-manifest.json"
          if [ -f "$MANIFEST_PATH" ]; then
            echo "Found worker-manifest.json. Preparing wrangler arguments."
            SECRETS_LIST=$(jq -r '.secrets[]' "$MANIFEST_PATH")
            VARS_LIST=$(jq -r '.vars[]' "$MANIFEST_PATH")

            # Always add PACKAGE_VERSION to the vars
            if [ -n "$VARS_LIST" ]; then
              VARS_LIST="${VARS_LIST}\nPACKAGE_VERSION"
            else
              VARS_LIST="PACKAGE_VERSION"
            fi

            echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV

            {
              echo "secrets_list<<EOF"
              echo "$SECRETS_LIST"
              echo "EOF"
              echo "vars_list<<EOF"
              echo "$VARS_LIST"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          else
            echo "::warning::worker-manifest.json not found. No secrets or vars will be bound."
          fi

      - name: Load .env file
        shell: bash
        run: |
          if [ -f "./.env" ]; then
            echo "Sourcing .env file..."
            grep -v '^[[:space:]]*#' ./.env | grep -v '^[[:space:]]*$' | grep '=' >> $GITHUB_ENV
            echo "Finished processing .env file for GITHUB_ENV."
          else
            echo -e "\u001b[31mError: .env file not found at ./.\u001b[0m"
            exit 1
          fi

      # Get cloudflare account id Infisical
      - name: Get cloudflare account id from Infisical
        uses: Infisical/secrets-action@08d433afae6a851f9081d0563a01a55fdf96568b #v1.0.11
        id: infisical_ro
        with:
          method: "universal"
          domain: ${{ env.INFISICAL_URL }}
          client-id: ${{ env.INFISICAL_CLIENT_ID }}
          client-secret: ${{ secrets.INFISICAL_CLIENT_SECRET }}
          project-slug: ${{ env.INFISICAL_PROJECT_SLUG }}
          env-slug: ${{ steps.env.outputs.environment }}
          secret-path: "/tofu"
          export-type: "env"

      # Get cloudflare token from Infisical
      - name: Get cloudflare token from Infisical
        uses: Infisical/secrets-action@08d433afae6a851f9081d0563a01a55fdf96568b #v1.0.11
        id: infisical_rw
        with:
          method: "universal"
          domain: ${{ env.INFISICAL_URL }}
          client-id: ${{ env.INFISICAL_CLIENT_ID }}
          client-secret: ${{ secrets.INFISICAL_CLIENT_SECRET }}
          project-slug: ${{ env.INFISICAL_PROJECT_SLUG }}
          env-slug: ${{ steps.env.outputs.environment }}
          secret-path: "/tofu_rw"
          export-type: "env"

      # Get cloudflare worker env from Infisical
      - name: Get cloudflare worker env from Infisical
        uses: Infisical/secrets-action@08d433afae6a851f9081d0563a01a55fdf96568b #v1.0.11
        id: infisical_cf_env
        with:
          method: "universal"
          domain: ${{ env.INFISICAL_URL }}
          client-id: ${{ env.INFISICAL_CLIENT_ID }}
          client-secret: ${{ secrets.INFISICAL_CLIENT_SECRET }}
          project-slug: ${{ env.INFISICAL_PROJECT_SLUG }}
          env-slug: ${{ steps.env.outputs.environment }}
          secret-path: "/cloudflare_worker_env"
          export-type: "env"

      - name: Debug environment and vars
        run: |
          echo "PACKAGE_VERSION environment variable: '$PACKAGE_VERSION'"
          echo "vars_list output: '${{ steps.prepare-files.outputs.vars_list }}'"

      - name: Deploy to Cloudflare
        uses: cloudflare/wrangler-action@392082e81ffbcb9ebdde27400634aa004b35ea37 # v3.14.0
        with:
          apiToken: ${{ env.TF_VAR_cloudflare_gha_workers_deployment }}
          accountId: ${{ env.TF_VAR_cloudflare_account_id }}
          workingDirectory: ${{ steps.prepare-files.outputs.dist_dir }}
          environment: ${{ steps.env.outputs.environment }}
          wranglerVersion: "4.25.1"
          command: 'versions upload --tag v${{ matrix.package.version }} --message "Deployed ${{ matrix.package.name }}@${{ matrix.package.version }}"'
          secrets: ${{ steps.prepare-files.outputs.secrets_list }}
          vars: ${{ steps.prepare-files.outputs.vars_list }}
          postCommands: |
            echo "Deploying version v${{ matrix.package.version }}"

            # Get the version ID and use it directly without storing in a variable
            npx wrangler versions list --env ${{ steps.env.outputs.environment }} --json | jq -r 'sort_by(.metadata.created_on) | reverse | .[0].id' > /tmp/version_id.txt

            echo "Version ID from file:"
            cat /tmp/version_id.txt

            echo "Version: $(cat /tmp/version_id.txt)"

            # Use the file content directly in the deploy command
            npx wrangler versions deploy "$(cat /tmp/version_id.txt)" --percentage 100 --env ${{ steps.env.outputs.environment }} --message "Deploy Version v${{ matrix.package.version }}" -y
